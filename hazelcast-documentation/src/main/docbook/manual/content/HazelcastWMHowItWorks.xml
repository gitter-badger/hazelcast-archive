<?xml version='1.0' encoding='UTF-8'?>
<sect1 xml:id="HazelcastWMHowItWorks" version='5.0' xmlns='http://docbook.org/ns/docbook'
       xmlns:xlink='http://www.w3.org/1999/xlink'
       xmlns:xi='http://www.w3.org/2001/XInclude'
       xmlns:ns5='http://www.w3.org/2000/svg'
       xmlns:ns4='http://www.w3.org/1998/Math/MathML'
       xmlns:ns3='http://www.w3.org/1999/xhtml'
       xmlns:db='http://docbook.org/ns/docbook'>
    <title>How It Works</title>
    <para>To understand how Hazelcast achieves clustering your application, we will go over what clusterWebapp. bat|sh
        script does and what happens at runtime. This could be a summary of how HazelcastWM works but some parts of the
        process are skipped for brevity.
        Hazelcast Webapp Manager will read your web.xml files and foreach web.xml file
        <itemizedlist>
            <listitem>
                <para>Adds a HazelcastWM Filter
                </para>
            </listitem>
            <listitem>
                <para>Removes all listener definitions and puts them into the HazelcastWM Filter definition so that
                    HazelcastWM will pass all corresponding events to those listeners.
                </para>
            </listitem>
            <listitem>
                <para>Adds a HazelcastWM listener that implements
                    <literal>ServletContextListener</literal>
                    and
                    <literal>ServletContextAttributeListener</literal>
                    interfaces. HazelcastWM listener will listen for the actual servlet container events and deligates
                    them to the application's listeners.
                </para>
            </listitem>
            <listitem>
                <para>Replaces each Servlet definition with Hazelcast servlet wrapper.
                </para>
            </listitem>
            <listitem>
                <para>Puts
                    <literal>&lt;%@ page extends="com.hazelcast.web.JspWrapper" %&gt;</literal>
                    at the top of every JSP.
                </para>
            </listitem>
        </itemizedlist>
        When a request hits the servlet container, servlet container will pass the request to HazelcastWM Filter and it
        will first find out if the request is already associated with a valid session. Then it wraps the request and
        response objects and fires
        <literal>ServletRequestEvent</literal>
        if necessary and pass the wrapped request/response through the filter chain by invoking <literal>
            chain.doFilter(wrappedRequest, wrappedResponse)</literal>.
        Throughout the chain, request might go through servlets, jsps, other filters. During the processing of the
        request, as attributes are added/removed to/from the request, HazelcastWM will fire corresponding events. When
        <literal>request.getSession(true)</literal>
        is called, then Hazelcast
        <literal>RequestWrapper</literal>
        object will return a
        <literal>HttpSession</literal>
        instance created by HazelcastWM. Servlet container never creates or know anything about the sessions.
        HazelcastWM will manage the sessions instead.As attributes added/removed to/from the session, HazelcastWM will
        fire corresponding events, dictated by the Servlet spec.
        When request is forwarded to resource or include a response from another resource via <literal>
            RequestDispatcher</literal>, HazelcastWM will wrap the dispatcher and when the wrapped dispatcher calls
        forward or include, it will hand container's original request/response objects over to the container's original
        dispatcher. That way container can work with its own request/response object, not with the wrapped ones.
        After the chain is completed, request will come back to the filter again. Filter will check if request is in a
        valid session again. If it is then it will go over the Serializable session attributes and persist them on the
        Hazelcast cluster.
        When requested is dispatched, container may not have to call the filters again. So HazelcastWM makes sure that
        the resource (JSP or Servlet) that the request is forwarded or included will get the original request/response,
        not the wrapped request/response. This is the reason why all application JSP and Servlets are also wrapped by
        HazelcastWM. That way when the
        <literal>service(ServletRequest req, ServletResponse res)</literal>
        method called on the wrapper servlet or JSP, it will delegate that call to your application JSP and Servlets
        with the wrapped request/request objects.
        For the containers that support Servlet 2.4 or higher, this is no need to wrap JSP and Servlets as Servlet 2.4
        spec let us tell container that it should go through filter when dispatching by using the
        <literal>&lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;</literal>
        and
        <literal>&lt;dispatcher&gt;INCLUDE&lt;/dispatcher&gt;</literal>
        elements when configuring filters.
        During that life-cycle of the application, HazelcastWM will collect statistics like response times, session
        count etc. and pass these metrics onto <literal>SnapshotListener</literal>s in the form of <literal>
            SnapshotEvent</literal>. Also note that regardless of the number of jsps and/or servlets a request goes
        through via
        <literal>RequestDispatcher.forward</literal>
        or
        <literal>RequestDispatcher.include</literal>
        calls, it is counted as a single request.

    </para>
</sect1>
